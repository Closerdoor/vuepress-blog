(window.webpackJsonp=window.webpackJsonp||[]).push([[90],{517:function(t,s,r){"use strict";r.r(s);var e=r(2),a=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h3",{attrs:{id:"html语义化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#html语义化"}},[t._v("#")]),t._v(" html语义化")]),t._v(" "),s("ul",[s("li",[t._v("语义化标签利于搜索引擎seo优化")]),t._v(" "),s("li",[t._v("在无css时也能形成html布局和结构")]),t._v(" "),s("li",[t._v("可读性增强")])]),t._v(" "),s("h3",{attrs:{id:"script标签种defer和async"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#script标签种defer和async"}},[t._v("#")]),t._v(" script标签种defer和async")]),t._v(" "),s("p",[t._v("async：异步下载\ndefer:不会造成阻塞，等html解析完再解析defer script")]),t._v(" "),s("h3",{attrs:{id:"从浏览器输入url到请求返回发生了什么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#从浏览器输入url到请求返回发生了什么"}},[t._v("#")]),t._v(" 从浏览器输入url到请求返回发生了什么")]),t._v(" "),s("ul",[s("li",[t._v("首先浏览器地址栏解析url，是否合法，补充协议，主机，端口、路径等，自动生成一个合法的url路径")]),t._v(" "),s("li",[t._v("提交给浏览器的网络进程，先寻找是否有缓存")]),t._v(" "),s("li",[t._v("dns解析，把域名解析成ip地址")]),t._v(" "),s("li",[t._v("建立TCP连接——三次握手")]),t._v(" "),s("li",[t._v("http请求")]),t._v(" "),s("li",[t._v("服务器收到http请求后返回报文")]),t._v(" "),s("li",[t._v("浏览器渲染页面")])]),t._v(" "),s("h3",{attrs:{id:"回流-reflow-和重绘-repaint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回流-reflow-和重绘-repaint"}},[t._v("#")]),t._v(" 回流（reflow）和重绘（repaint）")]),t._v(" "),s("p",[t._v("重排：无论通过什么方式影响了元素的几何信息(元素在视口内的位置和尺寸大小)，浏览器需要重新计算元素在视口内的几何属性，这个过程叫做重排。重绘：通过构造渲染树和重排（回流）阶段，我们知道了哪些节点是可见的，以及可见节点的样式和具体的几何信息(元素在视口内的位置和尺寸大小)，接下来就可以将渲染树的每个节点都转换为屏幕上的实际像素，这个阶段就叫做重绘。 如何减少重排和重绘？ 最小化重绘和重排，比如样式集中改变，使用添加新样式类名 .class 或 cssText 。批量操作 DOM，比如读取某元素 offsetWidth 属性存到一个临时变量，再去使用，而不是频繁使用这个计算属性；又比如利用 document.createDocumentFragment() 来添加要被添加的节点，处理完之后再插入到实际 DOM 中。使用 "),s("strong",[t._v("absolute")]),t._v(" 或 "),s("strong",[t._v("fixed")]),t._v(" 使元素脱离文档流，这在制作复杂的动画时对性能的影响比较明显。开启 GPU 加速，利用 css 属性 transform 、will-change 等，比如改变元素位置，我们使用 translate 会比使用绝对定位改变其 left 、top 等来的高效，因为它不会触发重排或重绘，transform 使浏览器为元素创建⼀个 GPU 图层，这使得动画元素在一个独立的层中进行渲染。当元素的内容没有发生改变，就没有必要进行重绘。")]),t._v(" "),s("h2",{attrs:{id:"性能优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能优化"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),s("p",[t._v("加载\n减少http请求(精灵图，文件合并)\n减少文件大小(资源、图片、文件压缩)\nCDN托管静态文件\n懒加载\nSSR服务端渲染\n利用浏览器缓存,避免重复请求\n性能/渲染\njs\n节流、防抖\n图片懒加载\ncss\n将css文件放在页面最上面\n充分利用css继承属性，减少代码量\n抽象提取公共样式，减少代码量\n属性值为0时，不加单位\n属性值为小于1的小数时，省略小数点前面的0\nDOM 操作优化\n减少dom操作，避免回流\n批量添加dom可先createElement创建并添加节点，fragment,最后一次性加入dom\n批量绑定事件，使用事件委托绑定父节点实现，利用了事件冒泡的特性\n在 DOM 操作时添加样式时尽量增加 class 属性，而不是通过 style 操作样式，以减少重排（Reflow）")])])}),[],!1,null,null,null);s.default=a.exports}}]);